<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instructor Dashboard - CSE 210 Attendance</title>
    <link rel="stylesheet" href="../styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <!-- Instructor Dashboard -->
        <div class="view active">
            <main>
                <div class="dashboard-container">
                    <!-- URL Management Section -->
                    <div class="url-management">
                        <h2>Manage Google Form URLs</h2>
                        <div class="url-input-section">
                            <div class="input-group">
                                <input type="text" id="formName" placeholder="Form Name (e.g., Lecture 1, Quiz 2)" class="form-input">
                                <input type="url" id="formUrl" placeholder="Google Form URL" class="form-input">
                                <input type="url" id="sheetUrl" placeholder="Google Sheet URL (for responses)" class="form-input">
                                <button id="addFormBtn" class="btn btn-primary">Add Form</button>
                            </div>
                        </div>
                        
                        <div class="forms-list">
                            <h3>Active Forms</h3>
                            <div id="formsList" class="forms-container">
                                <p class="no-forms">No forms added yet. Add your first form above.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Controls Section -->
                    <div class="controls-section">
                        <h2>Student View Controls</h2>
                        <div class="controls">
                            <button id="newSessionBtn" class="btn btn-primary">New Session</button>
                            <button id="refreshBtn" class="btn btn-secondary">Refresh QR</button>
                            <button id="toggleAutoRefresh" class="btn btn-secondary">Auto Refresh: ON</button>
                        </div>
                        <div class="session-info">
                            <p><strong>Current Session:</strong> <span id="currentSessionId">Loading...</span></p>
                            <p><strong>Auto Refresh:</strong> <span id="autoRefreshStatus">Every 5 seconds</span></p>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <script>
        // Anti-Screenshot QR Code Generator
        class AntiScreenshotQRGenerator {
            constructor() {
                this.size = 300;
                this.refreshInterval = 5000; // 5 seconds
                this.countdownInterval = null;
                this.qrRefreshInterval = null;
            }

            async generate(text, patternId = 0) {
                const qrContainer = document.getElementById('qrCode');
                
                // Use the exact text without modifications
                const uniqueText = text;
                
                // Method 1: Try QR Server API with unique parameters
                try {
                    const qrServerUrl = `https://api.qrserver.com/v1/create-qr-code/?size=${this.size}x${this.size}&data=${encodeURIComponent(uniqueText)}&ecc=M&margin=2`;
                    const img = document.createElement('img');
                    img.src = qrServerUrl;
                    img.alt = 'QR Code';
                    img.style.border = '3px solid #28a745';
                    img.style.borderRadius = '10px';
                    img.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.1)';
                    
                    return new Promise((resolve, reject) => {
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('QR Server API failed'));
                        
                        // Timeout after 3 seconds
                        setTimeout(() => reject(new Error('QR Server API timeout')), 3000);
                    });
                } catch (error) {
                    console.log('QR Server API failed, trying next method...');
                }

                // Method 2: Try Google Charts API with unique parameters
                try {
                    const googleChartsUrl = `https://chart.googleapis.com/chart?chs=${this.size}x${this.size}&cht=qr&chl=${encodeURIComponent(uniqueText)}&choe=UTF-8`;
                    const img = document.createElement('img');
                    img.src = googleChartsUrl;
                    img.alt = 'QR Code';
                    img.style.border = '3px solid #28a745';
                    img.style.borderRadius = '10px';
                    img.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.1)';
                    
                    return new Promise((resolve, reject) => {
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('Google Charts API failed'));
                        
                        // Timeout after 3 seconds
                        setTimeout(() => reject(new Error('Google Charts API timeout')), 3000);
                    });
                } catch (error) {
                    console.log('Google Charts API failed, using fallback...');
                }

                // Method 3: Fallback - Create a unique pattern
                return this.createUniquePatternQR(text, patternId);
            }

            createUniquePatternQR(text, patternId) {
                const canvas = document.createElement('canvas');
                canvas.width = this.size;
                canvas.height = this.size;
                const ctx = canvas.getContext('2d');

                // Fill background with unique color based on pattern ID
                const hue = (patternId * 137.5) % 360; // Golden angle for unique colors
                ctx.fillStyle = `hsl(${hue}, 20%, 95%)`;
                ctx.fillRect(0, 0, this.size, this.size);

                // Draw border with unique thickness
                const borderWidth = 2 + (patternId % 3);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = borderWidth;
                ctx.strokeRect(0, 0, this.size, this.size);

                // Draw corner squares with unique patterns
                const cornerSize = 60;
                ctx.fillStyle = '#000000';
                
                // Top-left corner with unique pattern
                ctx.fillRect(10, 10, cornerSize, cornerSize);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(25, 25, cornerSize/2, cornerSize/2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(35, 35, cornerSize/4, cornerSize/4);
                
                // Add unique dots based on pattern ID
                ctx.fillStyle = '#FF0000';
                for (let i = 0; i < patternId % 5; i++) {
                    ctx.fillRect(15 + i * 10, 15 + i * 5, 3, 3);
                }

                // Top-right corner
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.size - 70, 10, cornerSize, cornerSize);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(this.size - 55, 25, cornerSize/2, cornerSize/2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.size - 45, 35, cornerSize/4, cornerSize/4);

                // Bottom-left corner
                ctx.fillStyle = '#000000';
                ctx.fillRect(10, this.size - 70, cornerSize, cornerSize);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(25, this.size - 55, cornerSize/2, cornerSize/2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(35, this.size - 45, cornerSize/4, cornerSize/4);

                // Add unique text in center
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SCAN ME', this.size/2, this.size/2 - 30);
                ctx.fillText('QR CODE', this.size/2, this.size/2 - 10);
                ctx.fillText('ATTENDANCE', this.size/2, this.size/2 + 10);
                
                // Add pattern ID
                ctx.font = '10px Arial';
                ctx.fillText(`Pattern: ${patternId}`, this.size/2, this.size/2 + 30);

                canvas.style.border = '3px solid #28a745';
                canvas.style.borderRadius = '10px';
                canvas.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.1)';

                return Promise.resolve(canvas);
            }

            startCountdown(seconds) {
                const countdownElement = document.getElementById('countdown');
                if (!countdownElement) return;

                let timeLeft = seconds;
                
                const updateCountdown = () => {
                    countdownElement.textContent = `QR code refreshes in ${timeLeft} seconds`;
                    
                    if (timeLeft <= 3) {
                        countdownElement.style.color = '#dc3545';
                        countdownElement.style.fontSize = '16px';
                    } else if (timeLeft <= 5) {
                        countdownElement.style.color = '#ffc107';
                        countdownElement.style.fontSize = '14px';
                    } else {
                        countdownElement.style.color = '#28a745';
                        countdownElement.style.fontSize = '12px';
                    }
                    
                    timeLeft--;
                    
                    if (timeLeft < 0) {
                        clearInterval(this.countdownInterval);
                        countdownElement.textContent = 'Refreshing QR code...';
                    }
                };

                updateCountdown();
                this.countdownInterval = setInterval(updateCountdown, 1000);
            }

            stopCountdown() {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
            }
        }

        // Form Manager
        class FormManager {
            constructor() {
                this.forms = this.loadForms();
                this.currentFormIndex = 0;
            }

            loadForms() {
                const saved = localStorage.getItem('attendanceForms');
                if (saved) {
                    return JSON.parse(saved);
                }
                // Default form if none exist
                return [{
                    name: 'Default Attendance',
                    url: 'https://docs.google.com/forms/d/e/1FAIpQLSfJQOOhFtkqpmmHIyNf_XE_EHAL9v5JsiPJ7D0cAnHVpagBTA/viewform',
                    sheetUrl: 'https://docs.google.com/spreadsheets/d/1FAIpQLSfJQOOhFtkqpmmHIyNf_XE_EHAL9v5JsiPJ7D0cAnHVpagBTA/edit'
                }];
            }

            saveForms() {
                localStorage.setItem('attendanceForms', JSON.stringify(this.forms));
            }

            addForm(name, url, sheetUrl) {
                if (!name.trim() || !url.trim()) {
                    throw new Error('Form name and URL are required');
                }
                
                // Validate URLs
                try {
                    new URL(url);
                    if (sheetUrl && sheetUrl.trim()) {
                        new URL(sheetUrl.trim());
                    }
                } catch {
                    throw new Error('Please enter valid URLs');
                }

                this.forms.push({ 
                    name: name.trim(), 
                    url: url.trim(),
                    sheetUrl: sheetUrl ? sheetUrl.trim() : ''
                });
                this.saveForms();
                return this.forms.length - 1;
            }

            removeForm(index) {
                if (index >= 0 && index < this.forms.length) {
                    this.forms.splice(index, 1);
                    this.saveForms();
                    
                    // Adjust current index if needed
                    if (this.currentFormIndex >= this.forms.length) {
                        this.currentFormIndex = Math.max(0, this.forms.length - 1);
                    }
                }
            }

            getCurrentForm() {
                if (this.forms.length === 0) return null;
                return this.forms[this.currentFormIndex];
            }

            nextForm() {
                if (this.forms.length > 1) {
                    this.currentFormIndex = (this.currentFormIndex + 1) % this.forms.length;
                }
            }

            previousForm() {
                if (this.forms.length > 1) {
                    this.currentFormIndex = this.currentFormIndex === 0 
                        ? this.forms.length - 1 
                        : this.currentFormIndex - 1;
                }
            }

            setCurrentForm(index) {
                if (index >= 0 && index < this.forms.length) {
                    this.currentFormIndex = index;
                }
            }
        }

        // Google Sheets Integration
        class GoogleSheetsIntegration {
            constructor() {
                this.apiKey = null; // Will be set by user
                this.sheetId = null; // Will be extracted from form URL
            }

            extractSheetId(sheetUrl) {
                // Extract Google Sheets ID from sheet URL
                // Format: https://docs.google.com/spreadsheets/d/SHEET_ID/edit
                try {
                    const url = new URL(sheetUrl);
                    const pathParts = url.pathname.split('/');
                    const sheetIndex = pathParts.indexOf('d');
                    if (sheetIndex !== -1 && sheetIndex + 1 < pathParts.length) {
                        return pathParts[sheetIndex + 1];
                    }
                    throw new Error('Invalid Google Sheets URL format');
                } catch (error) {
                    console.error('Error extracting sheet ID:', error);
                    throw new Error('Please provide a valid Google Sheets URL');
                }
            }

            async fetchSheetData(sheetId, range = 'A:Z') {
                if (!this.apiKey) {
                    throw new Error('Google Sheets API key not configured. Please add your API key in the settings.');
                }

                const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${range}?key=${this.apiKey}`;
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    return data.values || [];
                } catch (error) {
                    console.error('Error fetching sheet data:', error);
                    throw new Error('Failed to fetch data from Google Sheets. Please check your API key and sheet permissions.');
                }
            }

            parseAttendanceData(rawData) {
                if (!rawData || rawData.length < 2) {
                    return { questions: [], totalResponses: 0 };
                }

                const headers = rawData[0];
                const data = rawData.slice(1);
                
                // Find columns with "Question" in the header
                const questionColumns = headers.map((header, index) => {
                    if (header && header.toLowerCase().includes('question')) {
                        return {
                            index: index,
                            title: header,
                            responses: []
                        };
                    }
                    return null;
                }).filter(col => col !== null);

                if (questionColumns.length === 0) {
                    throw new Error('No question columns found. Please ensure your form has questions with "Question" in the column header.');
                }

                // Extract responses for each question
                questionColumns.forEach(questionCol => {
                    data.forEach(row => {
                        const response = row[questionCol.index];
                        if (response && response.trim()) {
                            questionCol.responses.push(response.trim());
                        }
                    });
                });

                // Convert to chart data format
                const questions = questionColumns.map(questionCol => {
                    // Count frequency of each response
                    const responseCounts = {};
                    questionCol.responses.forEach(response => {
                        responseCounts[response] = (responseCounts[response] || 0) + 1;
                    });

                    // Convert to chart format
                    const chartData = Object.keys(responseCounts).map(response => ({
                        label: response,
                        count: responseCounts[response]
                    })).sort((a, b) => b.count - a.count); // Sort by count descending

                    return {
                        id: questionCol.title,
                        title: questionCol.title,
                        responses: chartData,
                        totalResponses: questionCol.responses.length
                    };
                });

                return {
                    questions,
                    totalResponses: data.length
                };
            }

            extractTimestamp(sessionId) {
                // Extract timestamp from session ID format: session_timestamp_random
                const match = sessionId.match(/session_(\d+)_/);
                return match ? parseInt(match[1]) : Date.now();
            }

            parseBySubmissionOrder(data) {
                // Group responses by submission order (every 10 responses = 1 session)
                const sessionSize = 10;
                const sessions = [];
                
                for (let i = 0; i < data.length; i += sessionSize) {
                    const sessionData = data.slice(i, i + sessionSize);
                    const sessionNumber = Math.floor(i / sessionSize) + 1;
                    
                    sessions.push({
                        id: `Session ${sessionNumber}`,
                        count: sessionData.length,
                        timestamp: Date.now() - (sessions.length * 60000), // 1 minute apart
                        responses: sessionData
                    });
                }
                
                return {
                    sessions,
                    totalResponses: data.length
                };
            }

            createTimePeriodKey(timestamp) {
                // Group by hour for better visualization
                const date = new Date(timestamp);
                const hour = date.getHours();
                const dateStr = date.toDateString();
                return `${dateStr} ${hour}:00`;
            }

            parseTimestamp(timeKey) {
                // Parse time key back to timestamp
                try {
                    const [dateStr, timeStr] = timeKey.split(' ');
                    const [hour] = timeStr.split(':');
                    const date = new Date(dateStr);
                    date.setHours(parseInt(hour));
                    return date.getTime();
                } catch (error) {
                    return Date.now();
                }
            }
        }

        // Chart Manager
        class ChartManager {
            constructor() {
                this.chart = null;
            }

            createAttendanceChart(data, containerId) {
                const ctx = document.getElementById(containerId);
                if (!ctx) {
                    console.error('Chart container not found:', containerId);
                    throw new Error('Chart container not found');
                }

                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js library not loaded');
                    throw new Error('Chart.js library not loaded. Please refresh the page.');
                }

                // Destroy existing chart if it exists
                if (this.chart) {
                    this.chart.destroy();
                }

                // Use the first question for the chart
                const firstQuestion = data.questions[0];
                if (!firstQuestion) {
                    throw new Error('No question data found');
                }

                const labels = firstQuestion.responses.map(response => response.label);
                const counts = firstQuestion.responses.map(response => response.count);

                this.chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Response Count',
                            data: counts,
                            backgroundColor: 'rgba(102, 126, 234, 0.8)',
                            borderColor: 'rgba(102, 126, 234, 1)',
                            borderWidth: 2,
                            borderRadius: 8,
                            borderSkipped: false,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: firstQuestion.title,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 1
                                },
                                title: {
                                    display: true,
                                    text: 'Number of Responses'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Response Options'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            }
                        },
                        animation: {
                            duration: 1000,
                            easing: 'easeInOutQuart'
                        }
                    }
                });

                return this.chart;
            }

            destroy() {
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = null;
                }
            }

            createSimpleChart(data, containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                // Use the first question for the chart
                const firstQuestion = data.questions[0];
                if (!firstQuestion) {
                    container.innerHTML = '<div class="error">No question data found</div>';
                    return;
                }

                // Create a simple HTML-based chart
                const maxCount = Math.max(...firstQuestion.responses.map(r => r.count));
                const chartHtml = `
                    <div class="simple-chart">
                        <h4>${firstQuestion.title}</h4>
                        <div class="chart-bars">
                            ${firstQuestion.responses.map(response => {
                                const height = (response.count / maxCount) * 200;
                                return `
                                    <div class="chart-bar">
                                        <div class="bar" style="height: ${height}px;" title="${response.count} responses"></div>
                                        <div class="bar-label">${response.count}</div>
                                        <div class="bar-date">${response.label}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <div class="chart-summary">
                            <p>Total Responses: ${firstQuestion.totalResponses}</p>
                            <p>Response Options: ${firstQuestion.responses.length}</p>
                        </div>
                    </div>
                `;
                
                container.innerHTML = chartHtml;
            }
        }

        // Anti-Screenshot Attendance QR Scanner
        class InstructorDashboard {
            constructor() {
                this.currentSessionId = null;
                this.formManager = new FormManager();
                this.qrGenerator = new AntiScreenshotQRGenerator();
                this.patternId = 0;
                this.autoRefreshEnabled = true;
                this.init();
            }

            init() {
                this.generateNewSession();
                this.setupEventListeners();
                this.startQRRefreshCycle();
                this.updateFormInfo();
            }

            generateSessionId() {
                const timestamp = Date.now();
                const random = Math.random().toString(36).substring(2, 15);
                return `session_${timestamp}_${random}`;
            }

            generateNewSession() {
                this.currentSessionId = this.generateSessionId();
                this.patternId = 0; // Reset pattern ID for new session
                this.updateSessionInfo();
                this.generateQRCode();
            }

            updateSessionInfo() {
                const currentSessionIdElement = document.getElementById('currentSessionId');
                if (currentSessionIdElement) {
                    currentSessionIdElement.textContent = this.currentSessionId;
                }
            }

            async generateQRCode() {
                const qrContainer = document.getElementById('qrCode');
                
                if (!qrContainer) {
                    console.error('QR code container not found');
                    return;
                }

                const currentForm = this.formManager.getCurrentForm();
                if (!currentForm) {
                    qrContainer.innerHTML = `
                        <div class="error">
                            <h3>No Forms Available</h3>
                            <p>Please add a Google Form URL in the instructor dashboard.</p>
                        </div>
                    `;
                    return;
                }

                // Use the exact Google Form URL provided
                const attendanceUrl = currentForm.url;
                
                console.log('Generating QR code for URL:', attendanceUrl);
                console.log('Session ID:', this.currentSessionId);
                console.log('Pattern ID:', this.patternId);
                console.log('Current Form:', currentForm.name);
                
                // Show loading only for initial generation, not refreshes
                if (this.patternId === 0) {
                    qrContainer.innerHTML = '<div class="loading"></div><p>Generating QR code...</p>';
                }
                
                try {
                    // Generate QR code with unique pattern
                    const qrElement = await this.qrGenerator.generate(attendanceUrl, this.patternId);
                    
                    // Clear container and add QR code
                    qrContainer.innerHTML = '';
                    qrContainer.appendChild(qrElement);
                    
                    // Add click handler to copy URL
                    qrElement.style.cursor = 'pointer';
                    qrElement.title = 'Click to copy URL';
                    qrElement.onclick = () => {
                        navigator.clipboard.writeText(attendanceUrl).then(() => {
                            this.showNotification('URL copied to clipboard!', 'success');
                        }).catch(() => {
                            // Fallback for older browsers
                            const textArea = document.createElement('textarea');
                            textArea.value = attendanceUrl;
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                            this.showNotification('URL copied to clipboard!', 'success');
                        });
                    };
                    
                    // Start countdown
                    this.qrGenerator.startCountdown(this.qrGenerator.refreshInterval / 1000);
                    
                    console.log('QR code generated successfully with pattern ID:', this.patternId);
                    
                } catch (error) {
                    console.error('Error generating QR code:', error);
                    qrContainer.innerHTML = `
                        <div class="error">
                            <h3>QR Code Generation Failed</h3>
                            <p>Error: ${error.message}</p>
                            <button onclick="window.instructorDashboard.generateQRCode()">Retry</button>
                        </div>
                    `;
                }
            }

            startQRRefreshCycle() {
                // Refresh QR code every 5 seconds
                this.qrRefreshInterval = setInterval(() => {
                    this.patternId++;
                    this.generateQRCode();
                    this.updateSessionInfo();
                    console.log('QR code refreshed with new pattern ID:', this.patternId);
                }, this.qrGenerator.refreshInterval);
            }

            stopQRRefreshCycle() {
                if (this.qrRefreshInterval) {
                    clearInterval(this.qrRefreshInterval);
                    this.qrRefreshInterval = null;
                }
                this.qrGenerator.stopCountdown();
            }

            setupEventListeners() {
                // Dashboard controls
                const newSessionBtn = document.getElementById('newSessionBtn');
                const refreshBtn = document.getElementById('refreshBtn');
                const toggleAutoRefreshBtn = document.getElementById('toggleAutoRefresh');

                if (newSessionBtn) {
                    newSessionBtn.addEventListener('click', () => {
                        this.stopQRRefreshCycle();
                        this.generateNewSession();
                        this.startQRRefreshCycle();
                        this.showNotification('New session generated!', 'success');
                    });
                }

                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => {
                        this.patternId++;
                        this.generateQRCode();
                        this.updateSessionInfo();
                        this.showNotification('QR code refreshed!', 'success');
                    });
                }

                if (toggleAutoRefreshBtn) {
                    toggleAutoRefreshBtn.addEventListener('click', () => {
                        this.autoRefreshEnabled = !this.autoRefreshEnabled;
                        if (this.autoRefreshEnabled) {
                            this.startQRRefreshCycle();
                            toggleAutoRefreshBtn.textContent = 'Auto Refresh: ON';
                            this.showNotification('Auto refresh enabled', 'success');
                        } else {
                            this.stopQRRefreshCycle();
                            toggleAutoRefreshBtn.textContent = 'Auto Refresh: OFF';
                            this.showNotification('Auto refresh disabled', 'info');
                        }
                    });
                }

                // Form management
                this.setupFormManagement();

                // Auto-refresh session every 5 minutes for security
                setInterval(() => {
                    this.stopQRRefreshCycle();
                    this.generateNewSession();
                    this.startQRRefreshCycle();
                    console.log('Session auto-refreshed for security');
                }, 5 * 60 * 1000); // 5 minutes
            }

            setupFormManagement() {
                const addFormBtn = document.getElementById('addFormBtn');
                const formNameInput = document.getElementById('formName');
                const formUrlInput = document.getElementById('formUrl');
                const sheetUrlInput = document.getElementById('sheetUrl');

                if (addFormBtn) {
                    addFormBtn.addEventListener('click', () => {
                        const name = formNameInput.value.trim();
                        const url = formUrlInput.value.trim();
                        const sheetUrl = sheetUrlInput.value.trim();
                        
                        try {
                            const index = this.formManager.addForm(name, url, sheetUrl);
                            this.updateDashboard();
                            this.updateFormInfo();
                            
                            // Clear inputs
                            formNameInput.value = '';
                            formUrlInput.value = '';
                            sheetUrlInput.value = '';
                            
                            this.showNotification(`Form "${name}" added successfully!`, 'success');
                        } catch (error) {
                            this.showNotification(error.message, 'error');
                        }
                    });
                }

                // Allow Enter key to add form
                [formNameInput, formUrlInput, sheetUrlInput].forEach(input => {
                    if (input) {
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                addFormBtn.click();
                            }
                        });
                    }
                });
            }

            updateDashboard() {
                this.updateFormsList();
                this.updateSessionInfo();
            }

            updateFormsList() {
                const formsList = document.getElementById('formsList');
                if (!formsList) return;

                if (this.formManager.forms.length === 0) {
                    formsList.innerHTML = '<p class="no-forms">No forms added yet. Add your first form above.</p>';
                    return;
                }

                formsList.innerHTML = this.formManager.forms.map((form, index) => `
                    <div class="form-item ${index === this.formManager.currentFormIndex ? 'active' : ''}">
                        <div class="form-info">
                            <h4>${form.name}</h4>
                            <p class="form-url">Form: ${form.url}</p>
                            ${form.sheetUrl ? `<p class="sheet-url">Sheet: ${form.sheetUrl}</p>` : '<p class="sheet-url no-sheet">No sheet URL provided</p>'}
                        </div>
                        <div class="form-actions">
                            <button class="btn btn-small ${index === this.formManager.currentFormIndex ? 'btn-primary' : 'btn-secondary'}" 
                                    onclick="window.instructorDashboard.setCurrentForm(${index})">
                                ${index === this.formManager.currentFormIndex ? 'Active' : 'Set Active'}
                            </button>
                            <button class="btn btn-small btn-danger" onclick="window.instructorDashboard.removeForm(${index})">
                                Remove
                            </button>
                        </div>
                    </div>
                `).join('');
            }

            setCurrentForm(index) {
                this.formManager.setCurrentForm(index);
                this.updateDashboard();
                this.updateFormInfo();
                this.generateQRCode();
                this.showNotification(`Switched to "${this.formManager.getCurrentForm().name}"`, 'success');
            }

            removeForm(index) {
                const form = this.formManager.forms[index];
                if (confirm(`Are you sure you want to remove "${form.name}"?`)) {
                    this.formManager.removeForm(index);
                    this.updateDashboard();
                    this.updateFormInfo();
                    this.generateQRCode();
                    this.showNotification(`Form "${form.name}" removed`, 'info');
                }
            }

            updateFormInfo() {
                const currentFormName = document.getElementById('currentFormName');
                if (currentFormName) {
                    const currentForm = this.formManager.getCurrentForm();
                    currentFormName.textContent = currentForm ? currentForm.name : 'No forms available';
                }
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 20px;
                    border-radius: 10px;
                    color: white;
                    font-weight: 600;
                    z-index: 1000;
                    animation: slideIn 0.3s ease;
                    background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#667eea'};
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
                `;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }

            getCurrentSessionId() {
                return this.currentSessionId;
            }

            getAttendanceUrl() {
                const currentForm = this.formManager.getCurrentForm();
                if (!currentForm) return null;
                return currentForm.url;
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const instructorDashboard = new InstructorDashboard();
            window.instructorDashboard = instructorDashboard;
            
            console.log('Instructor Dashboard initialized');
            console.log('Current session ID:', instructorDashboard.getCurrentSessionId());
            console.log('Attendance URL:', instructorDashboard.getAttendanceUrl());
        });
    </script>
</body>
</html>
